---
title: "Using `checkyourself` to simulate species distributions."
author: "Scott W. Yanco, Andrew L. McDevitt, Laurel M. Hartley, Michael B. Wunder"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{checkyourself}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Questions about this vignette or the `chekyourself` package should be directed to Scott Yanco at: Scott.Yanco@ucdenver.edu  

# Introduction

This vignette demonstrates how the `checkyourself` package can be used to simulate a simple agent-based species distribution model (SDM) in a hypothesis vetting process (Yanco et al. *in prep*).  Note that the number of parameterizations and model iterations is large and may take a substantial amount of time to complete. Note, also, that many of the processes documented here are stochastic in nature so results may not match exactly those depicted in the analyses.  

This package contains code to simulate a patchy landscape consisting of two habitat types and to implement three SDM models on that landscape:  
1. **Null Model:** Individuals settle the landscape randomly with no influence of habitat or neighbors.  
1. **Habitat Preference (HP) Model:** Individuals settle the landscape preferring "Habitat A" over "Habitat B".
1. **Conspecific Attraction (CA) Model:** Individuals settle the landscape preferring to settle near already-settled locations.

Many of the functions included in this package are called by the top-level functions described in this vignette and are not intended to be called directly by the user in running the models as constructed.  Therefore, in this document we only describe how to run the models in their simplest forms.  However, we encourage readers interested in modifying, expanding, or evaluating these models to view the code directly.  All functions are documented in the code such that the model logic should be clear.  

# Simulating a Patchy Landscape  

The package allows the user to simulate a landscape of arbitrary size containing two types of habitats.  The habitats are "grown" as patches and the user may set the target number and size of patches.  

The first step is to load the `checkyourself` package If the `checkyourself` package has not yet been installed, it can be downloaded directly using the package `devtools` by calling: `devtools::install_github("yanco\checkyourself")`.  

```{r}
library(checkyourself)
```

We can create a set of matrices on which the SDM simulations can run with a call to `simlandscapes` the arguments of which define the nature of the landscape as well as the relative degree of habitat preference to be exhibited in the habitat preference simulations (this degree of preference is "baked into" the landscape but can be ignored by the null and conspecific attraction models).  
```{r}
#declare parameterizations for habitat preference models (must be done as part 
#of landscape generation process).
A.coef <- c(1.5, 2, 2.5, 3, 3.5) 
lands <- simlandscapes(A.coef = A.coef, matsize = 100, 
                       n.clusters = 50, size.clusters = 100)
```

This returns a list, the first element of the list is an array which contains a column for each selection coefficient(s) `A.coef` and the value of all cells in that column match  the value of the selection coefficient(s) `A.coef`.  

The second element of the list is an array containing the values of each of the five habitat matrices, one for each value of `A.coef` supplied but normalized to a probability of selection. 

The third element of the list is an ID matrix of the correct dimension that is used by the conspecific attraction model to identify landscape locations.

# Run Simulations

We are now ready to simulate the multiple parameterizations of the three models on this simulated landscape.  We first establish the declarations which parameterize the models and determine the number of individual agents included in each model as well as the number of iterations of each model parameterization to run.  Note that we have already declared the parameterization for the HP Model as part of the landscape generation process (`A.coef`).  

```{r}
reps <- 2 #number of iterations of the simulation
n.individ <- 100 #number of animals to simulate settling
radius <- c(1,3,5,10,25) #define settlment radius for conspecific attraction
```

## Null Model

The Null Model can be run with a single call to `rep.rand`.  We supply `rep.rand` with several of the parameterizations from above.  We also need to supply the function with one of the habitat matrices in in the object `lands` as well as the corresponding `A.coef`.  While the simulation itself does not utilize this habitat matrix, because part of the output reports the proportion of settled location within Habitat A one of the habitat matrices is required.  It does not matter which one since they are identical in their spatial geometry and the magnitude of the preference encoded is not considered. The only requirement is that the habitat matrix supplied must match the value of `A.coef` supplied, since that value serves as the "key" to which cells are part of Habitat A.  Remember that the habitat matrices are stored in the second dimension of the habitat array, which is, itself, the first element of the list `lands`. Below we simply use the first habitat matrix and the first value of `A.coef`.

```{r eval=FALSE}
NULLmod <- repRand(reps=reps, n.individ = n.individ, hab.mat = lands[[1]][,1], 
                   A.coef = A.coef[1])
```

## Habitat Preference Model

The HP Model is run by a call to `rep.hab`. This function takes all the same arguments as `rep.rand` plus the probability matrices contained in the second element of `lands`.  Note that for this model we must supply all the habitat matrices and values of `A.coef` so that the model can iterate through each parameterization.

```{r eval=FALSE}
HABmod <- repHab(p.mat=lands[[2]], hab.mat = lands[[1]], reps = reps, 
                 n.individ = n.individ, A.coef = A.coef)
```

## Conspecific Attraction Model

The CA Model is run with a call to `rep.con`. This model again requires one of the habitat matrices contained in the first element of `lands` and the corresponding value from `A.coef` as was the case for the Null Model.  In addition to the `reps` and `n.individ` required by all the models, this function also required the vector of parameterizations for the CA Model contained in `radius`.  Finally, this function requires that we supply a matrix with cell values corresponding to cell IDs in the argument `ID.mat`.  Here we give the function this matrix which is contained in the third element of `lands` .

```{r eval=FALSE}
CAmod <- repCon(reps = reps, radius = radius, ID.mat = lands[[3]], 
                hab.mat = lands[[1]][,1], n.individ = n.individ, 
                A.coef = A.coef[1])
```

#Analysis and Visualization

We can pull the ranges of the sampling distributions for each model parametrization with the function `compilerangesSDM`.

```{r}
simdat <- compilerangesSDM(nulldata = NULLmod, habdata = HABmod, 
                           condata= CAmod, A.coef = A.coef, radius = radius)
```

We'll first produce a whiskers plot showing the range of the sampling distributions produced by the simulations arranged by parametrization.  This is a useful plot for estimatingestimating overlap between outcomes, as well as the overall amount of variance produced by each simulation and structures in variance across parameterizations.

```{r}
require(ggplot2)
whiskers <- ggplot(data=simdat, aes(xmin = low, xmax = upp, 
                                             y = parameter)) +
  geom_errorbarh() +
  facet_grid(model ~ ., scales = "free_y", space = "free_y") +
  xlab("Proportion Habitat A") +
  ylab("Parameter Value") + 
  ggtitle("Sampling Distribution Ranges") +
  theme(axis.ticks.y = element_blank(), axis.title = element_text(size=8), 
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(t = 0, r = 0, b = 0.2, l = 0, unit = "in"),
        panel.background = element_rect(fill= "white", color = "black"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank())
whiskers
```

Next we can produce a heat map showing the showing the proportion of overlap between model-parameterization combinations (1 represents complete overlap, 0 represents no overlap). Panels clockwise from top-left: (Null∩CA)/Null shows the proportion of null model simulations that overlapped the range of conspecific attraction models for each parameterization; (CA∩HP)/CA shows the proportion of conspecific attraction model simulations that overlapped the range of habitat preference models for each parameterization; (CA∩Null)/CA shows the proportion of conspecific attraction model simulations that overlapped the range of null models for each parameterization; (HP∩Null)/HP shows the proportion of habitat preference model simulations that overlapped the range of null models for each parameterization; (HP∩CA)/HP shows the proportion of habitat preference model simulations that overlapped the range of conspecific attraction models for each parameterization; and, (Null∩HP)/Null shows the proportion of null model simulations that overlapped the range of habitat preference models for each parameterization. 

```{r}

```

